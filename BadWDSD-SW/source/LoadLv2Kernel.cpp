#include "Include.h"

void LoadLv2Kernel(const char *fileName, uint32_t type)
{
	PrintLog("LoadLv2Kernel(), fileName = %s\n", fileName);

	if (strlen(fileName) > 24)
	{
		PrintLog("file name too long! Abort!()\n");

		abort();
		return;
	}

	char fullPath[512];
	sprintf(fullPath, "/dev_flash/sys/%s", fileName);

	PrintLog("fullPath = %s\n", fullPath);

	if (!IsFileExist(fullPath))
	{
		PrintLog("file not found! Abort!()\n");

		abort();
		return;
	}

	bool found = false;
	uint64_t offset = 0;

	{
		uint64_t t1 = GetTimeInMs();

		for (uint64_t i = 0; i < (16 * 1024 * 1024); i += 4)
		{
			uint64_t v;
			lv1_read(i, 8, &v);

			if (v == 0x2F6F732F6C76325FULL)
			{
				found = true;
				offset = (i - 4);

				break;
			}

			uint64_t t2 = GetTimeInMs();

			if ((t2 - t1) >= 2000)
			{
				lv2_beep_single();
				t1 = t2;
			}
		}
	}

	if (!found)
	{
		PrintLog("offset not found!, Abort!()\n");

		abort();
		return;
	}

	PrintLog("offset = 0x%lx\n", offset);

	{
		char fullPath[512];
		sprintf(fullPath, "/local_sys0/sys/%s", fileName);

		PrintLog("fullPath2 = %s\n", fullPath);

		size_t len = strlen(fullPath);
		lv1_write(offset, len + 1, fullPath);
	}

	//if (type == LoadLv2KernelType_e::OtherOS_Fself)
	{
		PrintLog("Patching initial lpar size...\n");

		uint64_t initial_lpar_size_offset = offset + 0x127;
		PrintLog("initial_lpar_size_offset = 0x%lx\n", initial_lpar_size_offset);

		uint8_t v = 0x1B; // 128M
		lv1_write(initial_lpar_size_offset, 1, &v);
	}

	{
		// install our patch

		bool auth_lv2_offset_found = false;
		uint64_t auth_lv2_offset;

		{
			for (uint64_t i = 0; i < (16 * 1024 * 1024); i += 4)
			{
				uint64_t v[3];
				lv1_read(i, 24, v);

				if ((v[0] == 0xF821FF517C0802A6) && (v[1] == 0xFB610088FB810090) && (v[2] == 0xFBC100A07C7C1B78))
				{
					auth_lv2_offset_found = true;
					auth_lv2_offset = i;

					break;
				}
			}
		}

		if (!auth_lv2_offset_found)
		{
			PrintLog("auth_lv2_offset not found!\n");
		}
		else
		{
			PrintLog("auth_lv2_offset = 0x%lx\n", auth_lv2_offset);

			// max function size = 644

			if (type == LoadLv2KernelType_e::Fself || type == LoadLv2KernelType_e::OtherOS_Fself)
			{
				PrintLog("Writing our fself loader patch...\n");

				if (our_lv1_auth_lv2_hook_fself_do_size > 644)
				{
					PrintLog("function size too big!\n");

					abort();
					return;
				}

				PrintLog("Patch size = %lu\n", our_lv1_auth_lv2_hook_fself_do_size);

				lv1_write(auth_lv2_offset,
						  our_lv1_auth_lv2_hook_fself_do_size,
						  (void *)our_lv1_auth_lv2_hook_fself_do);
			}
			else if (type == LoadLv2KernelType_e::OtherOS_ZFself)
			{
				PrintLog("Writing our stage4j patch...\n");

				static const uint8_t stage4j[] = {
					0x38, 0x21, 0xFF, 0x80, 0x7C, 0x08, 0x02, 0xA6, 0xF8, 0x01, 0x00, 0x00, 0xF8, 0x61, 0x00, 0x08, 0xF8, 0x81, 0x00, 0x10, 0xF8, 0xA1, 0x00, 0x18, 0x3D, 0x60, 0x00, 0x01, 0x61, 0x6B, 0x00, 0x03, 0x38, 0x80, 0x69, 0x96, 0x38, 0xA0, 0x00, 0x89,
					0x7C, 0x66, 0x1B, 0x78, 0x7C, 0x00, 0x04, 0xAC, 0x44, 0x00, 0x00, 0x02, 0x2C, 0x26, 0x33, 0x33, 0x41, 0x82, 0x00, 0xB8, 0x38, 0x80, 0x69, 0x96, 0x38, 0xA0, 0x00, 0x20, 0x38, 0xC0, 0x11, 0x11, 0x7C, 0x00, 0x04, 0xAC, 0x44, 0x00, 0x00, 0x02,
					0xE8, 0x61, 0x00, 0x18, 0x39, 0x00, 0x00, 0x00, 0x39, 0x20, 0x00, 0x00, 0xE9, 0x43, 0x00, 0x10, 0x7D, 0x29, 0x52, 0x14, 0xE9, 0x43, 0x00, 0x18, 0x7D, 0x29, 0x52, 0x14, 0x38, 0x80, 0x69, 0x96, 0x3C, 0xC8, 0x0C, 0x00, 0x7D, 0x43, 0x42, 0x14,
					0x28, 0x29, 0x00, 0x07, 0x41, 0x81, 0x00, 0xF4, 0x38, 0xA0, 0x00, 0x08, 0x88, 0xEA, 0x00, 0x00, 0x39, 0x40, 0x00, 0x01, 0xF8, 0x01, 0x00, 0x20, 0xF9, 0x01, 0x00, 0x28, 0xF9, 0x21, 0x00, 0x30, 0xF9, 0x41, 0x00, 0x38, 0xF8, 0x61, 0x00, 0x40,
					0x7C, 0x00, 0x04, 0xAC, 0x44, 0x00, 0x00, 0x02, 0xE8, 0x61, 0x00, 0x40, 0xE9, 0x41, 0x00, 0x38, 0xE9, 0x21, 0x00, 0x30, 0xE9, 0x01, 0x00, 0x28, 0xE8, 0x01, 0x00, 0x20, 0x7D, 0x08, 0x52, 0x14, 0x7D, 0x2A, 0x48, 0x50, 0x38, 0x00, 0x00, 0x00,
					0x7C, 0x09, 0x00, 0x00, 0x41, 0x82, 0x00, 0x08, 0x4B, 0xFF, 0xFF, 0x9C, 0x3D, 0x60, 0x00, 0x01, 0x61, 0x6B, 0x00, 0x03, 0x38, 0x80, 0x69, 0x96, 0x38, 0xA0, 0x00, 0x20, 0x38, 0xC0, 0x22, 0x22, 0x7C, 0x00, 0x04, 0xAC, 0x44, 0x00, 0x00, 0x02,
					0xE9, 0x41, 0x00, 0x10, 0x3C, 0x60, 0x4C, 0x4F, 0x60, 0x63, 0x41, 0x44, 0x90, 0x6A, 0x00, 0x00, 0x39, 0x4A, 0x00, 0x04, 0x3C, 0x60, 0x4D, 0x45, 0x60, 0x63, 0x58, 0x58, 0x90, 0x6A, 0x00, 0x00, 0x39, 0x4A, 0x00, 0x04, 0x3C, 0x60, 0x58, 0x58,
					0x60, 0x63, 0x4C, 0x4F, 0x90, 0x6A, 0x00, 0x00, 0x39, 0x4A, 0x00, 0x04, 0x3C, 0x60, 0x41, 0x44, 0x60, 0x63, 0x4D, 0x45, 0x90, 0x6A, 0x00, 0x00, 0x3D, 0x60, 0x00, 0x01, 0x61, 0x6B, 0x00, 0x03, 0x38, 0x80, 0x69, 0x96, 0x38, 0xA0, 0x00, 0x21,
					0x7C, 0x00, 0x04, 0xAC, 0x44, 0x00, 0x00, 0x02, 0x38, 0x80, 0x69, 0x96, 0x38, 0xA0, 0x00, 0x20, 0x38, 0xC0, 0x33, 0x33, 0x7C, 0x00, 0x04, 0xAC, 0x44, 0x00, 0x00, 0x02, 0xE8, 0x01, 0x00, 0x00, 0x7C, 0x08, 0x03, 0xA6, 0x38, 0x21, 0x00, 0x80,
					0x38, 0x60, 0x00, 0x00, 0x4E, 0x80, 0x00, 0x20, 0x38, 0xA0, 0x00, 0x02, 0xE8, 0xEA, 0x00, 0x00, 0x39, 0x40, 0x00, 0x08, 0x4B, 0xFF, 0xFF, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
					0x00, 0x00, 0x00, 0x00, 0x01, 0x7A, 0x52, 0x00, 0x04, 0x78, 0x41, 0x01, 0x1B, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x18, 0xFF, 0xFF, 0xFE, 0x58, 0x00, 0x00, 0x01, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
				  };

				lv1_write(auth_lv2_offset,
					sizeof(stage4j),
					stage4j);
			}
		}
	}

	{
		bool mmap_size_offset_found = false;
		uint64_t mmap_size_offset;

		// 7C 7C 1B 78 7F C3 F3 78 7F 86 E3 78

		for (uint64_t i = 0; i < (16 * 1024 * 1024); i += 4)
		{
			uint32_t v[3];
			lv1_read(i, 12, v);

			if ((v[0] == 0x7C7C1B78) && (v[1] == 0x7FC3F378) && (v[2] == 0x7F86E378))
			{
				mmap_size_offset_found = true;
				mmap_size_offset = i;

				break;
			}
		}

		if (!mmap_size_offset_found)
		{
			PrintLog("mmap_size_offset not found!, Abort!()\n");

			abort();
			return;
		}

		PrintLog("mmap_size_offset = 0x%lx\n", mmap_size_offset);

		//uint32_t v = 0x3B831000;
		uint32_t v = 0x3B837000;
		lv1_write(mmap_size_offset, 4, &v);
	}

	WaitInMs(1000);
	lv2_beep_triple();

	PrintLog("Booting lv2_kernel...\n");
	lv2_boot_lv2_kernel();
}